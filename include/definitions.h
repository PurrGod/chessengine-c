// definitions.h

#ifndef DEFINITIONS_H
#define DEFINITIONS_H

#include <stdint.h>
#include <time.h> // Needed for time management

#ifdef _WIN32
#include <windows.h>
#else
#include <sys/time.h>
#endif

typedef unsigned long long U64;

// A struct to hold all the information controlling the search
typedef struct {
    long starttime;
    long stoptime;
    int depth;
    int timeset;
    int stopped;
    
    // We can add more info here later, like nodes searched
    U64 nodes;

} SearchInfo;

//unsigned long long

#define ctz(x) __builtin_ctzll(x)
#define clz(x) __builtin_clzll(x)

//max game moves
#define MAXGAMEMOVES 2048 //half moves
#define MAX_DEPTH 64 // Max search depth


// move list
typedef struct{
    int moves[256];
    int count;
} moveList;

// move encoding
// A move is encoded as follows:
// 0-5:   To Square
// 6-11:  From Square
// 12-15: Captured Piece Type
// 16-19: Promotion Piece Type
// 20:    En Passant Flag
// 21:    Castling Flag
#define MOVE_TO(m)          ((m) & 0x3F)
#define MOVE_FROM(m)        (((m) >> 6) & 0x3F)
#define MOVE_CAPTURED(m)    (((m) >> 12) & 0xF)
#define MOVE_PROMOTION(m)   (((m) >> 16) & 0xF)

// constants
#define MOVE_IS_ENPASSANT   (1 << 20)
#define MOVE_IS_CASTLE      (1 << 21) 


//information for undo moves
typedef struct{
    int move;
    int castlePerm;
    int enPas;
    int fiftyMove;
    int side;
    U64 posKey;
} S_undo;
// Around 2048 half moves in a game
// We can store the entire history of the game in an array of S_undo structures which is around 2048 elements long


typedef struct {
    U64 pawns[2];    // 0 for white, 1 for black
    U64 knights[2];
    U64 bishops[2];
    U64 rooks[2];
    U64 queens[2];
    U64 kings[2];
    U64 occupied[2]; // 0 for white's occupied, 1 for black's occupied
    U64 all_pieces;  // All pieces combined (both white and black)

    int side; // easy way to keep track of side, initialize to white first or 0
    int enPas;
    int ply; //number of half moves
    int hisPly;

    //check history[] to see if posKey repeats itself
    // a posKey can be generated by taking the XOR of the bitboards of every
    // piece and use that to get a hash. We can now use this for checking
    // repeated positions.
    U64 posKey; //unique key for that specific position that is 64 bit long, unique for each position
    int fiftyMove; //status of the fiftymove rule

    int castlePerm; //1001 represents castle permission 

    int pceNum[13]; //stats of piece number
    int bigPce[3];  //pieces that are not pawns
    int majorPce[3]; //rook queen king
    int minorPce[3]; //knight bishop

    S_undo history[MAXGAMEMOVES]; //we have an array of all the moves, we can iterate 
                                  //to anywhere to find all the details regarding the board position

} Bitboards;



// Board dimensions
#define BOARD_SIZE 64
#define FILE_COUNT 8
#define RANK_COUNT 8

// Colors
#define WHITE 0
#define BLACK 1


// Rank and file masks
#define RANK_1_MASK 0x00000000000000FFULL
#define RANK_2_MASK 0x000000000000FF00ULL
#define RANK_3_MASK 0x0000000000FF0000ULL
#define RANK_4_MASK 0x00000000FF000000ULL
#define RANK_5_MASK 0x000000FF00000000ULL
#define RANK_6_MASK 0x0000FF0000000000ULL
#define RANK_7_MASK 0x00FF000000000000ULL
#define RANK_8_MASK 0xFF00000000000000ULL
#define FILE_A_MASK 0x0101010101010101ULL
#define FILE_B_MASK 0x0202020202020202ULL
#define FILE_C_MASK 0x0404040404040404ULL
#define FILE_D_MASK 0x0808080808080808ULL
#define FILE_E_MASK 0x1010101010101010ULL
#define FILE_F_MASK 0x2020202020202020ULL
#define FILE_G_MASK 0x4040404040404040ULL
#define FILE_H_MASK 0x8080808080808080ULL

enum side{white = 0, black};

// Piece types
enum Pieces {
    EMPTY = 0,
    wPawn,
    wKnight,
    wBishop,
    wRook,
    wQueen,
    wKing,
    bPawn,
    bKnight,
    bBishop,
    bRook,
    bQueen,
    bKing,
};

// ray directions enum
// This enum is used as an index for our sliding attack table.
enum RayDirection {
    NORTH, EAST, SOUTH, WEST,
    NORTH_EAST, SOUTH_EAST, SOUTH_WEST, NORTH_WEST
};

// Square enum for standard bitboard indexing: LSB = A1 (0), MSB = H8 (63)
// LERF - Little Endian Rank File
enum Squares {
    A1 = 0, B1, C1, D1, E1, F1, G1, H1,
    A2, B2, C2, D2, E2, F2, G2, H2,
    A3, B3, C3, D3, E3, F3, G3, H3,
    A4, B4, C4, D4, E4, F4, G4, H4,
    A5, B5, C5, D5, E5, F5, G5, H5,
    A6, B6, C6, D6, E6, F6, G6, H6,
    A7, B7, C7, D7, E7, F7, G7, H7,
    A8, B8, C8, D8, E8, F8, G8, H8,
    NO_SQ // Useful for the En Pas variable.
};


//white and black castling
enum {WKCA = 1, WQCA = 2, BKCA = 4, BQCA = 8};

// Hashkeys



// Utility macros for bitwise operations
#define bit(n) (1ULL << (n)) // Create a bitmask for the nth square
#define setbit(b, n) ((b) |= bit(n)) // Set the nth bit in b
#define clearbit(b, n) ((b) &= ~bit(n)) // Clear the nth bit in b
#define isset(b, n) ((b) & bit(n)) // Check if the nth bit is set in b


//popbit and countbit functions

//popbit() returns the index of the LSB and flips the bit to 0
int popbits(U64 bitboard, int *indices);

//popbit() but deletes the bit as welll
int popdelbits(U64 *bitboard, int *indices);

//pop a single LSB in bb
U64 popabit(U64 *bb, int *lsb_index);


//countbit() returns the number of flipped bits
unsigned int cntbits(U64 bb);

void square_to_algebraic(int square, char *notation);
int algebraic_to_square(const char *notation);

int get_piece_on_square(Bitboards *bb, int square, int side);

U64 *get_piece_bitboard(Bitboards * bb, int piece);

#endif // DEFINITIONS_H

